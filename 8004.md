ПЛАН (Alchemy, “только по agentId”, минимум RPC, актуальные источники)

1. Цель и границы

* Вход: agentId (uint256)
* Выход (только объективные on-chain данные):
  A) exists (bool) — существует ли агент
  B) owner (address) — текущий владелец identity NFT (ERC-721)
  C) agentWallet (address) — текущий “agent wallet” (если контракт поддерживает)
  D) agentURI (string) — tokenURI (on-chain ссылка)
* Без индексации списков, без репутации, без name/description.

2. Контракты (Ethereum mainnet)

* IdentityRegistry (ERC-8004): 0x8004A169FB4a3325136EB29fA0ceB6D2e539a432
  Источник: официальный репозиторий erc-8004-contracts, раздел Contract Addresses. ([GitHub][1])

3. Документация Alchemy, на которую опираемся

* eth_call (JSON-RPC) — базовый метод для чтения ownerOf/tokenURI/getAgentWallet. ([Alchemy][2])
* Batch Requests — можно отправлять несколько eth_call одним HTTP запросом (экономия round-trip). ([Alchemy][3])
* Важно: batching для “enhanced APIs” alchemy_* не поддерживается, но нам они не нужны. ([Alchemy][4])
* eth_getLogs в этом варианте не обязателен. Если когда-то понадобится, у Alchemy есть ограничения по диапазонам и размеру ответа, лучше учитывать их отдельно. ([Alchemy][5])

4. Архитектура MCP (минимальная)

* MCP метод: get_agent_by_id(agentId)
* Реализация: 1 HTTP запрос к Alchemy (JSON-RPC batch), в котором 3 eth_call:

  1. ownerOf(agentId)
  2. tokenURI(agentId)
  3. getAgentWallet(agentId)
* Без фонового индексатора, без БД. Опционально: маленький кеш (in-memory или Redis) на 30–300 секунд.

5. Оптимизация запросов к RPC (самое важное)
   5.1 Делать 3 чтения одним batch HTTP запросом

* Alchemy поддерживает JSON-RPC batch (до 1000 запросов в одном batch по HTTP; для нас это всегда 3). ([Alchemy][3])
* Это НЕ уменьшает число RPC-вызовов “логически”, но сильно уменьшает сетевые задержки и стоимость на уровне HTTP.

5.2 Не использовать eth_getLogs в этом режиме

* Для “только по agentId” всё читается через eth_call.
* Логи понадобятся только если ты захочешь историю (mint/transfer history). Тогда уже отдельный модуль.

5.3 Кеширование

* Кешировать результат get_agent_by_id(agentId) на короткое время:

  * TTL 30–120 секунд для публичного API
  * TTL 5–15 секунд если нужна “почти realtime” актуальность
* Кешировать ошибки отдельно (например 5–15 секунд), чтобы не долбить RPC при несуществующем tokenId.

5.4 Дедупликация “одинаковых” запросов

* Если несколько клиентов одновременно спросили один agentId, объединяй их в один полёт (request coalescing).
* Это даёт ощутимую экономию на пиках.

6. ABI/кодирование calldata (минимум)
   Тебе не нужно тянуть полный ABI. Достаточно 3 сигнатур:

* ownerOf(uint256) returns (address)  (ERC-721)
* tokenURI(uint256) returns (string)  (ERC-721 Metadata)
* getAgentWallet(uint256) returns (address)  (ERC-8004 IdentityRegistry)

Кодируешь calldata через ethers.js/viem Interface по этим сигнатурам.
Примечание: контракт может быть proxy, но вызовы view-функций через proxy работают нормально; важно лишь, что функции реально доступны на адресе IdentityRegistry.

7. Логика “exists” и обработка ошибок

* Основной признак существования:

  * eth_call ownerOf(agentId)
  * если revert → exists=false
  * если вернул address → exists=true
* tokenURI и getAgentWallet:

  * если ownerOf revert: не вызывай их (или игнорируй ответы), сразу верни exists=false
  * если ownerOf ok, но tokenURI revert: верни agentURI=null и пометь status “uri_unavailable”
  * если getAgentWallet revert/нет метода: верни agentWallet=null и пометь “wallet_unsupported”
    (Это важно, чтобы MCP был устойчив к несовпадению реализаций/апгрейдам.)

8. Конкретные шаги внедрения (по порядку)
   Шаг 1: Создать Alchemy App

* Network: Ethereum Mainnet
* Получить HTTPS endpoint: [https://eth-mainnet.g.alchemy.com/v2/](https://eth-mainnet.g.alchemy.com/v2/)<API_KEY>
  Источник: eth_call docs показывают формат endpoint. ([Alchemy][2])

Шаг 2: Реализовать метод get_agent_by_id(agentId)

* Подготовить batch JSON-RPC из 3 объектов:
  a) eth_call ownerOf
  b) eth_call tokenURI
  c) eth_call getAgentWallet
* Отправить одним POST (batch request). ([Alchemy][3])

Шаг 3: Добавить устойчивую обработку revert

* ownerOf revert => exists=false
* остальные ответы обрабатывать только если ownerOf ok

Шаг 4: Добавить кеш + coalescing

* in-memory LRU (просто) или Redis (если несколько инстансов)

Шаг 5: Набор unit-тестов на 4 кейса

* несуществующий agentId
* существующий agentId, wallet установлен
* существующий agentId, wallet = 0x0
* tokenURI недоступен (revert/пусто/ошибка декодирования)

Шаг 6: Ограничения по rate limit

* Ввести простейший limiter на уровень MCP (например 10 rps на ключ/пользователя)
* На практике при batch и кеше лимиты Alchemy обычно не проблема для “по id”.

9. Что получится на выходе

* Очень простой и дешёвый по RPC модуль
* Никакой индексации
* Минимум точек отказа
* Стабильная “карточка агента” по agentId:

  * exists
  * owner
  * agentWallet (если поддерживается/доступен)
  * tokenURI (если доступен)



(Ссылки-источники, которые стоит держать рядом при реализации:

* Alchemy eth_call ([Alchemy][2])
* Alchemy Batch Requests ([Alchemy][3])
* Ограничения batching для enhanced APIs (нам не нужно, но важно не перепутать) ([Alchemy][4])
* Адрес IdentityRegistry на mainnet ([GitHub][1]))

[1]: https://github.com/erc-8004/erc-8004-contracts?utm_source=chatgpt.com "Registry contracts curated by the 8004 team"
[2]: https://www.alchemy.com/docs/chains/ethereum/ethereum-api-endpoints/eth-call?utm_source=chatgpt.com "eth_call | Alchemy Docs"
[3]: https://www.alchemy.com/docs/reference/batch-requests?utm_source=chatgpt.com "Batch Requests"
[4]: https://www.alchemy.com/support/does-alchemy-support-batch-requests?utm_source=chatgpt.com "Does Alchemy Support Batch Requests?"
[5]: https://www.alchemy.com/docs/chains/ethereum/ethereum-api-endpoints/eth-get-logs?utm_source=chatgpt.com "eth_getLogs | Alchemy Docs"
